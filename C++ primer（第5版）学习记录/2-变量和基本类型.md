### 1. 基本内置类型
                                                    --- 整型 --- short(16)、int(16)、long(32)、long long(64, C++11)
                                                   |                --- char(8)，一个char的大小 = 一个机器字节   
                                       --- 整型 --- --- 字符类型 ---| 
                                      |            |                --- wchar_t(宽字符, 16)、char16_t(Unicode字符)、char32_t，可用于扩展字符集
                                      |             --- 布尔类型 --- bool，最小尺寸未定义
                       --- 算术类型 ---
                      |               |              --- float(单精度，最小有效位6位)、double(双精度，最小有效位10位)、long double(扩展精度，最小有效位10位)
                      |                --- 浮点型 ---|
     基本内置类型 ---                                 --- 大多数编译器都实现了更高的精度，通常：float(32 bit，7有效位)、double(64 bit，16有效位)、long double(96或128 bit)
                      |
                       --- 空类型(void)：不对应具体的值 

#### 1.1 带符号类型和无符号类型
除去布尔型和扩展的字符型外，其他整型可以划分为 **带符号的** 和 **无符号的** 两种，带符号类型可以表示正负数或0，无符号类型仅能表示大于等于0的值。
- int、short、long和long long都是带符号的，在这些类型名前加 **unsigned** 就可以得到无符号类型。
- 字符型被分为三种：char、signed char和unsigned char。尽管分为三种，但是字符的表现形式只有两种：带符号的和无符号的。

   char 和 signed char 并不一样，类型 char 实际上会表现为 signed 和 unsigned 两种形式中的一种，具体是哪种则由编译器决定。

#### 1.2 类型转换
- 当赋给无符号类型一个负数时，结果等于这个负数加上无符号数的模，比如unsigned int u = -42; int 32位，对应的无符号数的模为2^32，故 u 的结果为 -42+2^32；
- 当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如：unsigned char（0-255），赋值为-1，结果为255%156=255；
- 当赋给带符号类型一个超出它表示范围的值时，结果是未定义的，程序可能继续工作，可能崩溃，也可能生成垃圾数据；
- 带符号类型和无符号类型混合运算时，会转换成无符号类型进行计算。当无符号数减去一个值时，不管该值是不是无符号数，其结果都不会是一个负值。

#### 1.3 字面值常量
- 可将整型字面值写作十进制数、八进制数（0开头）、十六进制数（0x或0X开头）。整型字面值具体的数据类型由它的值和符号决定，默认情况下，十进制字面值是带符号数，八和十六进制字面值可能是带符号的也可能是无符号的，类型为所能容纳当前值类型的尺寸最小者；
- 默认浮点型字面值是double类型，其他浮点型可通过后缀表示；
- 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则为字符串型字面值；字符串型字面值实际是由常量字符构成的数组，**编译器在每个字符串的结尾处添加一个空字符'\0'**;
- 可通过添加前缀或后缀，来改变整型、浮点型和字符型字面值的默认类型。

### 2. 变量

- 变量提供一个具名的、可供程序操作的存储空间；C++每个变量的数据类型决定着变量所占内存空间的大小和布局方式、能存储的值的范围以及能参与的运算。
- 引申：通常情况下，对象是指一块能存储数据并具有某种类型的内存空间

#### 2.1 变量定义
- C++中，初始化和赋值是两个完全不同的操作，初始化是创建变量时赋予其一个初始值，而赋值是把对象的当前值擦除，以一个新值来替代；
- 列表初始化：由花括号括起来的初始值来初始化变量；特点：若使用列表初始化且初始值存在丢失信息的风险，则编译器会报错：
  ```C++
  long double ld = 3.1415926536; 
  int a{ ld }, b = { ld }; //错误：不会执行类型转换，因为存在丢失信息的风险  
  int c(ld), d = ld; //正确：会执行类型转换，且确实丢失了部分值
  ```
- 定义变量时若没有指定初始值，则变量被默认初始化，默认值具体是什么由变量类型决定，同时定义变量的位置也对此有影响。
  - 内置类型的变量若未显示初始化，则它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将**不被初始化**，即它的值是未定义的。
  - 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类决定，若类允许这种行为，它将决定对象的初始值是什么。如下的Base类，其**成员变量将会被赋随机值**：
    ```C++
    struct Base
    {
    	Base() { std::cout << "Base Constructor\n"; }
    	~Base() { std::cout << "Base Destructor\n"; }
    	void getInfo() { std::cout << aa << " " << bb << " " << cc << std::endl; }
    private:
    	int aa;
    	int bb;
    	void* cc;
    };
    
    int main(int argc, const char* argv[])
    {
        Base base;
    	base.getNum();
    }
    ```
- C++支持分离式编译机制：允许将程序分割成若干个文件，每个文件可被独立编译。所以为支持分离式编译，C++将声明和定义区分开。声明规定了变量的类型和名字，而定义还申请存储空间及可能赋初始值。
  - 若想声明一个变量而不定义它，就在变量名前添加**关键字extern**，且不要显示地初始化变量：
    ```C++
    extern int i； //声明i而非定义i
    int j; //声明并定义j
    extern double pi = 3.1415; //extern语句包含初始值就不再是声明而是定义了
    ```
    


